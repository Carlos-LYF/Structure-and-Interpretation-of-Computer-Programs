#lang racket
(require compatibility/mlist)
(define (db x) (displayln x))
(define (pf . x) (apply printf x))
(for-each (lambda (T)

(define R (read))
(define C (read))
(define K (read))
(define A (build-vector R (lambda (i) (build-vector C (lambda (j) (read))))))
(define dis (build-vector R (lambda (i) (build-vector C (lambda (j) (build-vector (+ 1 K) (lambda (k) +inf.0)))))))
(vector-set! (vector-ref (vector-ref dis 0) 0) 0 0)

(define tail (mlist '(0 0 0)))

(define (go x y k d)
	(when (and (< -1 x R) (< -1 y C))
		(define p (vector-ref (vector-ref A x) y))
		(unless (eq? p 'W)
			(when (eq? p 'M) (set! k (+ k 1)))
			(when (<= k K)
				(when (< d (vector-ref (vector-ref (vector-ref dis x) y) k))
					(vector-set! (vector-ref (vector-ref dis x) y) k d)
					(set-mcdr! tail (mlist (list x y k)))
					(set! tail (mcdr tail))
				)
			)
		)
	)
)

(let loop ((head tail));(db head)
	(define u (mcar head))
	(define x (car u))
	(define y (cadr u))
	(define k (caddr u))
	(define d (vector-ref (vector-ref (vector-ref dis x) y) k));(pf "~a ~a ~a ~a\n" x y k d)
	(if (and (= x (- R 1)) (= y (- C 1)))
		(displayln d)
		(begin
			(set! d (+ d 1))
			(go (+ x 1) y k d)
			(go (- x 1) y k d)
			(go x (+ y 1) k d)
			(go x (- y 1) k d)
			(if (null? (mcdr head))
				(displayln "inf")
				(loop (mcdr head)))
		)
	)
)
)
(range (read))
)